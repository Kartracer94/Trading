<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trading Analyzer</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    *, *::before, *::after {
      box-sizing: border-box;
    }
    html, body {
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      width: 100%;
      max-width: 100vw;
    }
    #root {
      width: 100%;
      max-width: 100vw;
      overflow-x: hidden;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const TradingApp = () => {
      const [data, setData] = useState([]);
      const [analysis, setAnalysis] = useState(null);
      const [ticker, setTicker] = useState('AAPL');
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState(null);
      const [dataSource, setDataSource] = useState('demo');
      const [timeframe, setTimeframe] = useState('day');
      const [structureLookback, setStructureLookback] = useState('6months');
      const chartContainerRef = useRef(null);
      const chartRef = useRef(null);
      const API_KEY = '8sJBoZDCpg92UTI_7APnqoFRPWsIJ7oj';

      const getLookbackDays = (period) => {
        const periods = {
          '5days': 5,
          '10days': 10,
          '15days': 15,
          '1month': 30,
          '3months': 90,
          '6months': 180,
          '9months': 270,
          '1year': 365,
          '2years': 730
        };
        return periods[period] || 180;
      };

      const getTimeframeParams = (tf) => {
        const timeframes = {
          '5min': { multiplier: 5, timespan: 'minute', days: 10 },
          '15min': { multiplier: 15, timespan: 'minute', days: 10 },
          'hour': { multiplier: 1, timespan: 'hour', days: 90 },
          'day': { multiplier: 1, timespan: 'day', days: 730 },
          'week': { multiplier: 1, timespan: 'week', days: 730 }
        };
        return timeframes[tf];
      };

      const fetchRealData = async (symbol) => {
        setLoading(true);
        setError(null);
        try {
          const tfParams = getTimeframeParams(timeframe);
          const toDate = new Date();
          const fromDate = new Date();
          fromDate.setDate(toDate.getDate() - tfParams.days);
          
          const fromStr = fromDate.toISOString().split('T')[0];
          const toStr = toDate.toISOString().split('T')[0];
          
          const url = `https://api.polygon.io/v2/aggs/ticker/${symbol}/range/${tfParams.multiplier}/${tfParams.timespan}/${fromStr}/${toStr}?adjusted=true&sort=asc&limit=50000&apiKey=${API_KEY}`;
          
          const response = await fetch(url);
          
          if (!response.ok) {
            throw new Error('Failed to fetch data. Check if ticker is valid (e.g., AAPL, TSLA, MSFT)');
          }
          
          const result = await response.json();
          
          if (!result.results || result.results.length === 0) {
            throw new Error('No data available for this ticker and timeframe');
          }
          
          const candles = result.results.map(bar => ({
            time: bar.t,
            open: bar.o,
            high: bar.h,
            low: bar.l,
            close: bar.c,
            volume: bar.v || 0
          }));
          
          return candles;
        } catch (err) {
          setError(err.message);
          console.error('API Error:', err);
          return null;
        } finally {
          setLoading(false);
        }
      };

      const generateData = () => {
        const candles = [];
        let price = 45000;
        const now = Date.now();
        const dayInMs = 24 * 60 * 60 * 1000;
        
        for (let i = 0; i < 50; i++) {
          const change = (Math.random() - 0.5) * 1000;
          const open = price;
          const close = price + change;
          const high = Math.max(open, close) + Math.random() * 200;
          const low = Math.min(open, close) - Math.random() * 200;
          const volume = Math.random() * 1000000 + 500000;
          
          candles.push({ 
            time: now - ((49 - i) * dayInMs),
            open, 
            high, 
            low, 
            close, 
            volume 
          });
          price = close;
        }
        return candles;
      };

      const calculateEMA = (prices, period) => {
        const k = 2 / (period + 1);
        let ema = prices[0];
        const result = [ema];
        
        for (let i = 1; i < prices.length; i++) {
          ema = prices[i] * k + ema * (1 - k);
          result.push(ema);
        }
        return result;
      };

      const calculateMACD = (candles) => {
        const closes = candles.map(c => c.close);
        const ema12 = calculateEMA(closes, 12);
        const ema26 = calculateEMA(closes, 26);
        const macdLine = ema12.map((val, i) => val - ema26[i]);
        const signal = calculateEMA(macdLine, 9);
        const histogram = macdLine.map((val, i) => val - signal[i]);
        
        return { macdLine, signal, histogram };
      };

      const detectCandlePattern = (candle) => {
        const body = Math.abs(candle.close - candle.open);
        const upperWick = candle.high - Math.max(candle.close, candle.open);
        const lowerWick = Math.min(candle.close, candle.open) - candle.low;
        const range = candle.high - candle.low;
        
        if (body < range * 0.1) {
          return { name: 'Doji', signal: 'NEUTRAL' };
        }
        
        if (candle.close > candle.open && lowerWick > body * 2 && upperWick < body * 0.3) {
          return { name: 'Hammer', signal: 'BULLISH' };
        }
        
        if (candle.close < candle.open && upperWick > body * 2 && lowerWick < body * 0.3) {
          return { name: 'Shooting Star', signal: 'BEARISH' };
        }
        
        if (candle.close > candle.open && body > range * 0.7) {
          return { name: 'Strong Bullish', signal: 'BULLISH' };
        }
        
        if (candle.close < candle.open && body > range * 0.7) {
          return { name: 'Strong Bearish', signal: 'BEARISH' };
        }
        
        return { name: 'No Pattern', signal: 'NEUTRAL' };
      };

      const analyzeTrendStructure = (structures, candles) => {
        if (!structures || structures.length === 0) {
          return { trend: 'NEUTRAL', signal: 'No clear trend structure', description: 'Insufficient data to determine trend' };
        }

        const currentPrice = candles[candles.length - 1].close;
        
        const recentLH = structures.filter(s => s.structure === 'LH').sort((a, b) => b.time - a.time)[0];
        const recentHL = structures.filter(s => s.structure === 'HL').sort((a, b) => b.time - a.time)[0];
        const recentHH = structures.filter(s => s.structure === 'HH').sort((a, b) => b.time - a.time);
        const recentLL = structures.filter(s => s.structure === 'LL').sort((a, b) => b.time - a.time);
        
        if (recentLH && currentPrice > recentLH.price) {
          return {
            trend: 'BULLISH',
            signal: 'Bullish Structure Break',
            description: `Price broke above LH at ${recentLH.price.toFixed(2)}, indicating potential uptrend`
          };
        }
        
        if (recentHL && currentPrice < recentHL.price) {
          return {
            trend: 'BEARISH',
            signal: 'Bearish Structure Break',
            description: `Price broke below HL at ${recentHL.price.toFixed(2)}, indicating potential downtrend`
          };
        }
        
        const hasRecentHH = recentHH.length > 0 && recentHH[0].time > Date.now() - (30 * 24 * 60 * 60 * 1000);
        const hasRecentHL = recentHL && recentHL.time > Date.now() - (30 * 24 * 60 * 60 * 1000);
        const hasRecentLH = recentLH && recentLH.time > Date.now() - (30 * 24 * 60 * 60 * 1000);
        const hasRecentLL = recentLL.length > 0 && recentLL[0].time > Date.now() - (30 * 24 * 60 * 60 * 1000);
        
        if (hasRecentHH && hasRecentHL) {
          return {
            trend: 'BULLISH',
            signal: 'Uptrend Structure',
            description: 'Series of Higher Highs and Higher Lows forming'
          };
        }
        
        if (hasRecentLH && hasRecentLL) {
          return {
            trend: 'BEARISH',
            signal: 'Downtrend Structure',
            description: 'Series of Lower Highs and Lower Lows forming'
          };
        }
        
        return {
          trend: 'NEUTRAL',
          signal: 'Consolidation',
          description: 'No clear trend structure - market consolidating'
        };
      };

      const findSwingPoints = (candles) => {
        const swingPoints = [];
        const lookback = 3; // Number of candles to look back and forward
        const reversalThreshold = 0.01; // 1% reversal threshold
        
        for (let i = lookback; i < candles.length - lookback; i++) {
          const current = candles[i];
          
          // Get surrounding candles (3 on each side)
          const leftCandles = candles.slice(i - lookback, i);
          const rightCandles = candles.slice(i + 1, i + lookback + 1);
          const surroundingCandles = [...leftCandles, ...rightCandles];
          
          // Check for swing high - must be highest high within 3 bars on either side
          const isHighestHigh = surroundingCandles.every(c => current.high >= c.high);
          
          if (isHighestHigh) {
            // Check if price reverses down by at least 1% from the wick high
            let reversalConfirmed = false;
            for (const rc of rightCandles) {
              const reversalFromHigh = (current.high - rc.low) / current.high;
              if (reversalFromHigh >= reversalThreshold) {
                reversalConfirmed = true;
                break;
              }
            }
            
            if (reversalConfirmed) {
              // Avoid duplicate swing highs too close together
              const recentSwingHigh = swingPoints.filter(p => p.type === 'high').slice(-1)[0];
              if (!recentSwingHigh || i - recentSwingHigh.index >= 3) {
                swingPoints.push({
                  index: i,
                  time: candles[i].time,
                  price: current.high,
                  type: 'high'
                });
              }
            }
          }
          
          // Check for swing low - must be lowest low within 3 bars on either side
          const isLowestLow = surroundingCandles.every(c => current.low <= c.low);
          
          if (isLowestLow) {
            // Check if price reverses up by at least 1% from the wick low
            let reversalConfirmed = false;
            for (const rc of rightCandles) {
              const reversalFromLow = (rc.high - current.low) / current.low;
              if (reversalFromLow >= reversalThreshold) {
                reversalConfirmed = true;
                break;
              }
            }
            
            if (reversalConfirmed) {
              // Avoid duplicate swing lows too close together
              const recentSwingLow = swingPoints.filter(p => p.type === 'low').slice(-1)[0];
              if (!recentSwingLow || i - recentSwingLow.index >= 3) {
                swingPoints.push({
                  index: i,
                  time: candles[i].time,
                  price: current.low,
                  type: 'low'
                });
              }
            }
          }
        }
        
        return swingPoints;
      };

      const identifyStructureBreaks = (swingPoints, candles) => {
        const lookbackDays = getLookbackDays(structureLookback);
        const lookbackMs = lookbackDays * 24 * 60 * 60 * 1000;
        const cutoffTime = Date.now() - lookbackMs;
        
        const recentSwingPoints = swingPoints.filter(p => p.time >= cutoffTime);
        
        const highs = recentSwingPoints.filter(p => p.type === 'high');
        const lows = recentSwingPoints.filter(p => p.type === 'low');
        
        // First pass: identify all potential structure points
        const preliminaryStructures = [];
        
        // Identify HH and LH from highs
        for (let i = 1; i < highs.length; i++) {
          const currentHigh = highs[i];
          const prevHigh = highs[i - 1];
          
          if (currentHigh.price > prevHigh.price) {
            preliminaryStructures.push({
              ...currentHigh,
              structure: 'HH',
              color: '#10b981'
            });
          } else if (currentHigh.price < prevHigh.price) {
            preliminaryStructures.push({
              ...currentHigh,
              structure: 'LH',
              color: '#ef4444'
            });
          }
        }
        
        // Identify HL and LL from lows
        for (let i = 1; i < lows.length; i++) {
          const currentLow = lows[i];
          const prevLow = lows[i - 1];
          
          if (currentLow.price > prevLow.price) {
            preliminaryStructures.push({
              ...currentLow,
              structure: 'HL',
              color: '#10b981'
            });
          } else if (currentLow.price < prevLow.price) {
            preliminaryStructures.push({
              ...currentLow,
              structure: 'LL',
              color: '#ef4444'
            });
          }
        }
        
        // Sort all structures by time
        preliminaryStructures.sort((a, b) => a.time - b.time);
        
        // Second pass: filter based on the rules
        const finalStructures = [];
        
        for (let i = 0; i < preliminaryStructures.length; i++) {
          const current = preliminaryStructures[i];
          const prev = i > 0 ? preliminaryStructures[i - 1] : null;
          const next = i < preliminaryStructures.length - 1 ? preliminaryStructures[i + 1] : null;
          
          let shouldMark = true;
          
          // Rule 1: If a LH is preceded most recently by a HL and the immediate next swing point is another HL, do not mark the LH
          if (current.structure === 'LH' && prev && prev.structure === 'HL' && next && next.structure === 'HL') {
            shouldMark = false;
          }
          
          // Rule 2: If a HL is preceded most recently by a LH and the immediate next swing point is another LH, do not mark the HL
          if (current.structure === 'HL' && prev && prev.structure === 'LH' && next && next.structure === 'LH') {
            shouldMark = false;
          }
          
          // Rule 3: If a LL is preceded most recently by a HH and the immediate next swing point is another HH, do not mark the LL
          if (current.structure === 'LL' && prev && prev.structure === 'HH' && next && next.structure === 'HH') {
            shouldMark = false;
          }
          
          // Rule 4: If a HH is preceded most recently by a LL and the immediate next swing point is another HH, do not mark the HH
          if (current.structure === 'HH' && prev && prev.structure === 'LL' && next && next.structure === 'HH') {
            shouldMark = false;
          }
          
          if (shouldMark) {
            finalStructures.push(current);
          }
        }
        
        return finalStructures;
      };

      const analyzeData = (candles) => {
        const macd = calculateMACD(candles);
        const lastCandle = candles[candles.length - 1];
        const pattern = detectCandlePattern(lastCandle);
        const swingPoints = findSwingPoints(candles);
        const structures = identifyStructureBreaks(swingPoints, candles);
        const trendStructure = analyzeTrendStructure(structures, candles);
        
        const levels = swingPoints.filter(p => p.type === 'high' || p.type === 'low');
        
        const avgVolume = candles.reduce((sum, c) => sum + c.volume, 0) / candles.length;
        const volumeSignal = lastCandle.volume > avgVolume * 1.2 ? 'HIGH' : 
                            lastCandle.volume < avgVolume * 0.8 ? 'LOW' : 'NORMAL';
        
        const lastMacd = macd.histogram[macd.histogram.length - 1];
        const prevMacd = macd.histogram[macd.histogram.length - 2];
        
        let macdSignal = 'NEUTRAL';
        if (lastMacd > 0 && prevMacd <= 0) macdSignal = 'BULLISH CROSS';
        else if (lastMacd < 0 && prevMacd >= 0) macdSignal = 'BEARISH CROSS';
        else if (lastMacd > 0) macdSignal = 'BULLISH';
        else if (lastMacd < 0) macdSignal = 'BEARISH';
        
        const currentPrice = lastCandle.close;
        const nearSupport = levels.filter(l => l.type === 'low' && l.price < currentPrice)
          .sort((a, b) => b.price - a.price)[0];
        const nearResistance = levels.filter(l => l.type === 'high' && l.price > currentPrice)
          .sort((a, b) => a.price - b.price)[0];
        
        let score = 0;
        const signals = [];
        
        if (macdSignal.includes('BULLISH')) {
          score += 2;
          signals.push({ name: 'MACD ' + macdSignal, type: 'BULLISH' });
        } else if (macdSignal.includes('BEARISH')) {
          score -= 2;
          signals.push({ name: 'MACD ' + macdSignal, type: 'BEARISH' });
        }
        
        if (pattern.signal === 'BULLISH') {
          score += 1;
          signals.push({ name: 'Pattern: ' + pattern.name, type: 'BULLISH' });
        } else if (pattern.signal === 'BEARISH') {
          score -= 1;
          signals.push({ name: 'Pattern: ' + pattern.name, type: 'BEARISH' });
        }
        
        if (volumeSignal === 'HIGH') {
          signals.push({ name: 'High Volume', type: 'NEUTRAL' });
        }
        
        if (nearSupport && (currentPrice - nearSupport.price) / currentPrice < 0.02) {
          score += 1;
          signals.push({ name: 'Near Support', type: 'BULLISH' });
        }
        
        if (nearResistance && (nearResistance.price - currentPrice) / currentPrice < 0.02) {
          score -= 1;
          signals.push({ name: 'Near Resistance', type: 'BEARISH' });
        }
        
        let overallSignal = 'NEUTRAL';
        if (score >= 3) overallSignal = 'STRONG BUY';
        else if (score >= 1) overallSignal = 'BUY';
        else if (score <= -3) overallSignal = 'STRONG SELL';
        else if (score <= -1) overallSignal = 'SELL';
        
        return {
          macdSignal,
          pattern,
          volumeSignal,
          nearSupport,
          nearResistance,
          currentPrice,
          overallSignal,
          score,
          signals,
          avgVolume: avgVolume.toFixed(0),
          currentVolume: lastCandle.volume.toFixed(0),
          structures,
          trendStructure
        };
      };

      // Initialize with demo data on mount
      useEffect(() => {
        const candles = generateData();
        setData(candles);
        setAnalysis(analyzeData(candles));
      }, []);

      // Create chart when data changes
      useEffect(() => {
        if (data.length > 0 && chartContainerRef.current) {
          createTradingViewChart();
        }
        
        return () => {
          if (chartRef.current) {
            chartRef.current.remove();
            chartRef.current = null;
          }
        };
      }, [data, analysis]);

      const createTradingViewChart = () => {
        if (!window.LightweightCharts) {
          console.error('TradingView Lightweight Charts library not loaded');
          return;
        }

        if (chartRef.current) {
          chartRef.current.remove();
        }

        const container = chartContainerRef.current;
        
        const showTime = timeframe === '5min' || timeframe === '15min' || timeframe === 'hour';
        
        // Main candlestick chart with TradingView-like settings
        const chart = window.LightweightCharts.createChart(container, {
          width: container.clientWidth,
          height: 350,
          layout: {
            background: { type: 'solid', color: '#131722' },
            textColor: '#d1d4dc'
          },
          grid: {
            vertLines: { color: '#1e222d' },
            horzLines: { color: '#1e222d' }
          },
          crosshair: {
            mode: window.LightweightCharts.CrosshairMode.Normal,
            vertLine: {
              color: '#758696',
              width: 1,
              style: window.LightweightCharts.LineStyle.Dashed,
              labelBackgroundColor: '#2a2e39'
            },
            horzLine: {
              color: '#758696',
              width: 1,
              style: window.LightweightCharts.LineStyle.Dashed,
              labelBackgroundColor: '#2a2e39'
            }
          },
          rightPriceScale: {
            borderColor: '#2a2e39',
            scaleMargins: {
              top: 0.1,
              bottom: 0.1
            }
          },
          timeScale: {
            borderColor: '#2a2e39',
            timeVisible: showTime,
            secondsVisible: false,
            rightOffset: 12,
            barSpacing: 6,
            fixLeftEdge: false,
            fixRightEdge: false,
            lockVisibleTimeRangeOnResize: true,
            rightBarStaysOnScroll: true,
            shiftVisibleRangeOnNewBar: true
          },
          handleScroll: {
            mouseWheel: true,
            pressedMouseMove: true,
            horzTouchDrag: true,
            vertTouchDrag: false
          },
          handleScale: {
            axisPressedMouseMove: {
              time: true,
              price: false
            },
            axisDoubleClickReset: true,
            mouseWheel: true,
            pinch: true
          }
        });

        const candlestickSeries = chart.addCandlestickSeries({
          upColor: '#26a69a',
          downColor: '#ef5350',
          borderUpColor: '#26a69a',
          borderDownColor: '#ef5350',
          wickUpColor: '#26a69a',
          wickDownColor: '#ef5350'
        });

        const chartData = data.map((candle) => ({
          time: Math.floor(candle.time / 1000),
          open: candle.open,
          high: candle.high,
          low: candle.low,
          close: candle.close
        }));

        candlestickSeries.setData(chartData);

        // Add structure markers
        if (analysis && analysis.structures && analysis.structures.length > 0) {
          const markers = analysis.structures.map(structure => ({
            time: Math.floor(structure.time / 1000),
            position: structure.type === 'high' ? 'aboveBar' : 'belowBar',
            color: structure.color,
            shape: structure.type === 'high' ? 'arrowDown' : 'arrowUp',
            text: structure.structure
          }));
          
          candlestickSeries.setMarkers(markers);

          // Add horizontal lines for each structure
          analysis.structures.forEach(structure => {
            const structureTime = Math.floor(structure.time / 1000);
            const lastTime = Math.floor(data[data.length - 1].time / 1000);
            
            const lineSeries = chart.addLineSeries({
              color: structure.color,
              lineWidth: 1,
              lineStyle: window.LightweightCharts.LineStyle.Dashed,
              crosshairMarkerVisible: false,
              lastValueVisible: true,
              priceLineVisible: false
            });
            
            lineSeries.setData([
              { time: structureTime, value: structure.price },
              { time: lastTime, value: structure.price }
            ]);
          });
        }

        chart.timeScale().fitContent();

        // Create MACD chart below with matching TradingView style
        const macdContainer = document.getElementById('macd-chart-container');
        if (macdContainer) {
          macdContainer.innerHTML = '';
          
          const macdChart = window.LightweightCharts.createChart(macdContainer, {
            width: container.clientWidth,
            height: 120,
            layout: {
              background: { type: 'solid', color: '#131722' },
              textColor: '#d1d4dc'
            },
            grid: {
              vertLines: { color: '#1e222d' },
              horzLines: { color: '#1e222d' }
            },
            crosshair: {
              mode: window.LightweightCharts.CrosshairMode.Normal,
              vertLine: {
                color: '#758696',
                width: 1,
                style: window.LightweightCharts.LineStyle.Dashed,
                labelBackgroundColor: '#2a2e39'
              },
              horzLine: {
                color: '#758696',
                width: 1,
                style: window.LightweightCharts.LineStyle.Dashed,
                labelBackgroundColor: '#2a2e39'
              }
            },
            rightPriceScale: {
              borderColor: '#2a2e39',
              scaleMargins: {
                top: 0.1,
                bottom: 0.1
              }
            },
            timeScale: {
              borderColor: '#2a2e39',
              timeVisible: showTime,
              secondsVisible: false,
              rightOffset: 12,
              barSpacing: 6,
              fixLeftEdge: false,
              fixRightEdge: false,
              visible: true,
              rightBarStaysOnScroll: true
            },
            handleScroll: {
              mouseWheel: true,
              pressedMouseMove: true,
              horzTouchDrag: true,
              vertTouchDrag: false
            },
            handleScale: {
              axisPressedMouseMove: {
                time: true,
                price: false
              },
              axisDoubleClickReset: true,
              mouseWheel: true,
              pinch: true
            }
          });

          // Calculate MACD data
          const closes = data.map(c => c.close);
          const ema12 = calculateEMA(closes, 12);
          const ema26 = calculateEMA(closes, 26);
          const macdLine = ema12.map((val, i) => val - ema26[i]);
          const signalLine = calculateEMA(macdLine, 9);
          const histogram = macdLine.map((val, i) => val - signalLine[i]);

          // MACD Line (blue)
          const macdLineSeries = macdChart.addLineSeries({
            color: '#2962FF',
            lineWidth: 2,
            title: 'MACD',
            crosshairMarkerVisible: true,
            crosshairMarkerRadius: 4
          });

          const macdLineData = macdLine.map((val, i) => ({
            time: Math.floor(data[i].time / 1000),
            value: val
          }));
          macdLineSeries.setData(macdLineData);

          // Signal Line (orange)
          const signalLineSeries = macdChart.addLineSeries({
            color: '#FF6D00',
            lineWidth: 2,
            title: 'Signal',
            crosshairMarkerVisible: true,
            crosshairMarkerRadius: 4
          });

          const signalLineData = signalLine.map((val, i) => ({
            time: Math.floor(data[i].time / 1000),
            value: val
          }));
          signalLineSeries.setData(signalLineData);

          // Histogram (green/red bars)
          const histogramSeries = macdChart.addHistogramSeries({
            title: 'Histogram',
            priceLineVisible: false
          });

          const histogramData = histogram.map((val, i) => ({
            time: Math.floor(data[i].time / 1000),
            value: val,
            color: val >= 0 ? '#26a69a' : '#ef5350'
          }));
          histogramSeries.setData(histogramData);

          // Zero line
          const zeroLineSeries = macdChart.addLineSeries({
            color: '#4a4e59',
            lineWidth: 1,
            lineStyle: window.LightweightCharts.LineStyle.Solid,
            crosshairMarkerVisible: false,
            lastValueVisible: false,
            priceLineVisible: false
          });

          const zeroLineData = data.map(candle => ({
            time: Math.floor(candle.time / 1000),
            value: 0
          }));
          zeroLineSeries.setData(zeroLineData);

          macdChart.timeScale().fitContent();

          // Sync the time scales
          let isSyncing = false;
          
          chart.timeScale().subscribeVisibleLogicalRangeChange((logicalRange) => {
            if (isSyncing || !logicalRange) return;
            isSyncing = true;
            macdChart.timeScale().setVisibleLogicalRange(logicalRange);
            isSyncing = false;
          });

          macdChart.timeScale().subscribeVisibleLogicalRangeChange((logicalRange) => {
            if (isSyncing || !logicalRange) return;
            isSyncing = true;
            chart.timeScale().setVisibleLogicalRange(logicalRange);
            isSyncing = false;
          });

          // Handle resize for MACD chart
          const handleMacdResize = () => {
            macdChart.applyOptions({ width: container.clientWidth });
          };
          window.addEventListener('resize', handleMacdResize);

          // Store MACD chart reference for cleanup
          chartRef.current = {
            chart,
            macdChart,
            remove: () => {
              window.removeEventListener('resize', handleResize);
              window.removeEventListener('resize', handleMacdResize);
              chart.remove();
              macdChart.remove();
            }
          };
        }

        const handleResize = () => {
          chart.applyOptions({ width: container.clientWidth });
        };
        window.addEventListener('resize', handleResize);

        if (!chartRef.current) {
          chartRef.current = {
            chart,
            remove: () => {
              window.removeEventListener('resize', handleResize);
              chart.remove();
            }
          };
        }
      };

      const resetZoom = () => {
        if (chartRef.current) {
          if (chartRef.current.chart) {
            chartRef.current.chart.timeScale().fitContent();
          }
          if (chartRef.current.macdChart) {
            chartRef.current.macdChart.timeScale().fitContent();
          }
        }
      };

      const handleSearch = async () => {
        if (dataSource === 'real') {
          const candles = await fetchRealData(ticker);
          if (candles) {
            setData(candles);
            setAnalysis(analyzeData(candles));
          }
        } else {
          const candles = generateData();
          setData(candles);
          setAnalysis(analyzeData(candles));
        }
      };

      const refresh = () => {
        handleSearch();
      };

      if (!analysis) return <div className="p-8">Loading...</div>;

      const getColor = (signal) => {
        if (signal.includes('BUY')) return 'text-green-600';
        if (signal.includes('SELL')) return 'text-red-600';
        return 'text-gray-600';
      };

      const getBg = (signal) => {
        if (signal.includes('BUY')) return 'bg-green-100 border-green-300';
        if (signal.includes('SELL')) return 'bg-red-100 border-red-300';
        return 'bg-gray-100 border-gray-300';
      };

      return (
        <div className="min-h-screen bg-gray-50 p-4 overflow-x-hidden">
          <div className="max-w-5xl mx-auto w-full">
            <div className="flex justify-between items-center mb-6">
              <h1 className="text-2xl font-bold">Trading Analyzer</h1>
              <button onClick={refresh} disabled={loading} className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 text-sm">
                {loading ? 'Loading...' : 'Refresh'}
              </button>
            </div>

            <div className="bg-white p-4 rounded-lg shadow mb-6">
              <div className="grid grid-cols-1 md:grid-cols-5 gap-3">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Data Source</label>
                  <select 
                    value={dataSource} 
                    onChange={(e) => setDataSource(e.target.value)}
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm"
                  >
                    <option value="demo">Demo Data</option>
                    <option value="real">Real Market Data</option>
                  </select>
                </div>
                
                {dataSource === 'real' && (
                  <>
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Ticker Symbol</label>
                      <input
                        type="text"
                        value={ticker}
                        onChange={(e) => setTicker(e.target.value.toUpperCase())}
                        placeholder="AAPL, TSLA, MSFT..."
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm"
                      />
                    </div>
                    
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Timeframe</label>
                      <select 
                        value={timeframe} 
                        onChange={(e) => setTimeframe(e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm"
                      >
                        <option value="5min">5 Minutes</option>
                        <option value="15min">15 Minutes</option>
                        <option value="hour">1 Hour</option>
                        <option value="day">Daily</option>
                        <option value="week">Weekly</option>
                      </select>
                    </div>
                    
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Structure Lookback</label>
                      <select 
                        value={structureLookback} 
                        onChange={(e) => setStructureLookback(e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm"
                      >
                        <option value="5days">5 Days</option>
                        <option value="10days">10 Days</option>
                        <option value="15days">15 Days</option>
                        <option value="1month">1 Month</option>
                        <option value="3months">3 Months</option>
                        <option value="6months">6 Months</option>
                        <option value="9months">9 Months</option>
                        <option value="1year">1 Year</option>
                        <option value="2years">2 Years</option>
                      </select>
                    </div>
                  </>
                )}
                
                <div className="flex items-end">
                  <button 
                    onClick={handleSearch} 
                    disabled={loading}
                    className="w-full px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50 text-sm"
                  >
                    {loading ? 'Searching...' : 'Search'}
                  </button>
                </div>
              </div>
              
              {error && (
                <div className="mt-3 p-3 bg-red-100 border border-red-400 text-red-700 rounded text-sm">
                  <p className="font-bold">Error:</p>
                  <p>{error}</p>
                  <p className="text-xs mt-1">Try: AAPL, TSLA, MSFT, GOOGL, AMZN, NVDA</p>
                </div>
              )}
            </div>

            <div className={`p-6 rounded-lg shadow mb-6 border-2 ${getBg(analysis.overallSignal)}`}>
              <h2 className="text-lg font-semibold mb-1">
                Overall Signal {dataSource === 'real' ? `- ${ticker} (${timeframe.toUpperCase()})` : '(Demo)'}
              </h2>
              <div className={`text-4xl font-bold ${getColor(analysis.overallSignal)}`}>
                {analysis.overallSignal}
              </div>
              <div className="text-gray-600 mt-1 text-sm">Score: {analysis.score}</div>
              <div className="text-gray-800 mt-1">Price: ${analysis.currentPrice.toFixed(2)}</div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
              <div className="bg-white p-4 rounded-lg shadow">
                <h3 className="text-base font-semibold mb-2">MACD Analysis</h3>
                <div className="text-xl font-bold text-blue-600 mb-1">{analysis.macdSignal}</div>
                <p className="text-gray-600 text-xs">MACD indicator showing momentum</p>
              </div>

              <div className="bg-white p-4 rounded-lg shadow">
                <h3 className="text-base font-semibold mb-2">Trend Structure</h3>
                <div className={`text-xl font-bold mb-1 ${
                  analysis.trendStructure && analysis.trendStructure.trend === 'BULLISH' ? 'text-green-600' :
                  analysis.trendStructure && analysis.trendStructure.trend === 'BEARISH' ? 'text-red-600' :
                  'text-gray-600'
                }`}>
                  {analysis.trendStructure ? analysis.trendStructure.signal : 'Loading...'}
                </div>
                <p className="text-gray-600 text-xs">{analysis.trendStructure ? analysis.trendStructure.description : ''}</p>
              </div>

              <div className="bg-white p-4 rounded-lg shadow">
                <h3 className="text-base font-semibold mb-2">Support & Resistance</h3>
                {analysis.nearResistance && (
                  <div className="mb-2">
                    <div className="text-xs text-gray-600">Resistance</div>
                    <div className="text-lg font-bold text-red-600">${analysis.nearResistance.price.toFixed(2)}</div>
                  </div>
                )}
                {analysis.nearSupport && (
                  <div>
                    <div className="text-xs text-gray-600">Support</div>
                    <div className="text-lg font-bold text-green-600">${analysis.nearSupport.price.toFixed(2)}</div>
                  </div>
                )}
                {!analysis.nearResistance && !analysis.nearSupport && (
                  <div className="text-gray-600 text-sm">No nearby levels detected</div>
                )}
              </div>
            </div>

            <div className="bg-white p-4 rounded-lg shadow mb-6">
              <h3 className="text-base font-semibold mb-3">Active Signals</h3>
              <div className="space-y-2">
                {analysis.signals.map((sig, i) => (
                  <div key={i} className={`p-3 rounded ${
                    sig.type === 'BULLISH' ? 'bg-green-50 border border-green-200' :
                    sig.type === 'BEARISH' ? 'bg-red-50 border border-red-200' :
                    'bg-gray-50 border border-gray-200'
                  }`}>
                    <div className="flex justify-between items-center">
                      <span className="font-semibold text-sm">{sig.name}</span>
                      <span className={`px-2 py-1 rounded text-xs font-bold ${
                        sig.type === 'BULLISH' ? 'bg-green-600 text-white' :
                        sig.type === 'BEARISH' ? 'bg-red-600 text-white' :
                        'bg-gray-600 text-white'
                      }`}>
                        {sig.type}
                      </span>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            <div className="bg-gray-900 p-4 rounded-lg shadow overflow-hidden">
              <div className="flex justify-between items-center mb-3">
                <h3 className="text-lg font-semibold text-white">Interactive Candlestick Chart</h3>
                <button 
                  onClick={resetZoom}
                  className="px-3 py-1 bg-gray-700 text-white rounded hover:bg-gray-600 text-sm"
                >
                  Reset Zoom
                </button>
              </div>
              <div className="text-xs text-gray-400 mb-3">
                ðŸ’¡ <strong className="text-gray-300">Scroll</strong> to zoom â€¢ <strong className="text-gray-300">Drag</strong> to pan â€¢ <span className="text-teal-400 font-semibold">Green</span> = bullish â€¢ <span className="text-red-400 font-semibold">Red</span> = bearish
                <span className="ml-2">ðŸ“Š <strong className="text-gray-300">HH</strong> = Higher High â€¢ <strong className="text-gray-300">HL</strong> = Higher Low â€¢ <strong className="text-gray-300">LH</strong> = Lower High â€¢ <strong className="text-gray-300">LL</strong> = Lower Low</span>
              </div>
              <div ref={chartContainerRef} className="w-full" style={{height: '350px'}}></div>
              
              <div className="mt-2 mb-1 flex items-center gap-3 text-xs text-gray-400">
                <span className="font-semibold text-gray-300">MACD (12, 26, 9):</span>
                <span className="flex items-center gap-1">
                  <span className="w-2 h-0.5 bg-blue-500 inline-block"></span> MACD
                </span>
                <span className="flex items-center gap-1">
                  <span className="w-2 h-0.5 bg-orange-500 inline-block"></span> Signal
                </span>
                <span className="flex items-center gap-1">
                  <span className="w-2 h-2 bg-teal-500 inline-block"></span>
                  <span className="w-2 h-2 bg-red-400 inline-block"></span> Hist
                </span>
              </div>
              <div id="macd-chart-container" className="w-full" style={{height: '120px'}}></div>
              
              <div className="text-xs text-gray-500 mt-1">
                Powered by <a href="https://www.tradingview.com/" target="_blank" rel="noopener" className="text-blue-400 hover:underline">TradingView</a>
              </div>
            </div>
          </div>
        </div>
      );
    };

    ReactDOM.render(<TradingApp />, document.getElementById('root'));
  </script>
</body>
</html>
