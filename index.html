<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trading Analyzer</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const TradingApp = () => {
      const [data, setData] = useState([]);
      const [analysis, setAnalysis] = useState(null);
      const [ticker, setTicker] = useState('AAPL');
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState(null);
      const [dataSource, setDataSource] = useState('demo');
      const [timeframe, setTimeframe] = useState('day');
      const [structureLookback, setStructureLookback] = useState('6months');
      const chartContainerRef = useRef(null);
      const chartRef = useRef(null);
      const API_KEY = '8sJBoZDCpg92UTI_7APnqoFRPWsIJ7oj';

      const getLookbackDays = (period) => {
        const periods = {
          '5days': 5,
          '10days': 10,
          '15days': 15,
          '1month': 30,
          '3months': 90,
          '6months': 180,
          '9months': 270,
          '1year': 365,
          '2years': 730
        };
        return periods[period] || 180;
      };

      const getTimeframeParams = (tf) => {
        const timeframes = {
          '5min': { multiplier: 5, timespan: 'minute', days: 10 },
          '15min': { multiplier: 15, timespan: 'minute', days: 10 },
          'hour': { multiplier: 1, timespan: 'hour', days: 90 },
          'day': { multiplier: 1, timespan: 'day', days: 730 },
          'week': { multiplier: 1, timespan: 'week', days: 730 }
        };
        return timeframes[tf];
      };

      const fetchRealData = async (symbol) => {
        setLoading(true);
        setError(null);
        try {
          const tfParams = getTimeframeParams(timeframe);
          const toDate = new Date();
          const fromDate = new Date();
          fromDate.setDate(toDate.getDate() - tfParams.days);
          
          const fromStr = fromDate.toISOString().split('T')[0];
          const toStr = toDate.toISOString().split('T')[0];
          
          const url = `https://api.massive.com/v2/aggs/ticker/${symbol}/range/${tfParams.multiplier}/${tfParams.timespan}/${fromStr}/${toStr}?adjusted=true&sort=asc&limit=50000&apiKey=${API_KEY}`;
          
          const response = await fetch(url);
          
          if (!response.ok) {
            throw new Error('Failed to fetch data. Check if ticker is valid (e.g., AAPL, TSLA, MSFT)');
          }
          
          const result = await response.json();
          
          if (!result.results || result.results.length === 0) {
            throw new Error('No data available for this ticker and timeframe');
          }
          
          const candles = result.results.map(bar => ({
            time: bar.t, // Unix timestamp in milliseconds
            open: bar.o,
            high: bar.h,
            low: bar.l,
            close: bar.c,
            volume: bar.v || 0
          }));
          
          return candles;
        } catch (err) {
          setError(err.message);
          console.error('API Error:', err);
          return null;
        } finally {
          setLoading(false);
        }
      };

      const generateData = () => {
        const candles = [];
        let price = 45000;
        const now = Date.now();
        const dayInMs = 24 * 60 * 60 * 1000;
        
        for (let i = 0; i < 50; i++) {
          const change = (Math.random() - 0.5) * 1000;
          const open = price;
          const close = price + change;
          const high = Math.max(open, close) + Math.random() * 200;
          const low = Math.min(open, close) - Math.random() * 200;
          const volume = Math.random() * 1000000 + 500000;
          
          candles.push({ 
            time: now - ((49 - i) * dayInMs), // Unix timestamp in ms
            open, 
            high, 
            low, 
            close, 
            volume 
          });
          price = close;
        }
        return candles;
      };

      const calculateEMA = (prices, period) => {
        const k = 2 / (period + 1);
        let ema = prices[0];
        const result = [ema];
        
        for (let i = 1; i < prices.length; i++) {
          ema = prices[i] * k + ema * (1 - k);
          result.push(ema);
        }
        return result;
      };

      const calculateMACD = (candles) => {
        const closes = candles.map(c => c.close);
        const ema12 = calculateEMA(closes, 12);
        const ema26 = calculateEMA(closes, 26);
        const macdLine = ema12.map((val, i) => val - ema26[i]);
        const signal = calculateEMA(macdLine, 9);
        const histogram = macdLine.map((val, i) => val - signal[i]);
        
        return { macdLine, signal, histogram };
      };

      const detectCandlePattern = (candle) => {
        const body = Math.abs(candle.close - candle.open);
        const upperWick = candle.high - Math.max(candle.close, candle.open);
        const lowerWick = Math.min(candle.close, candle.open) - candle.low;
        const range = candle.high - candle.low;
        
        if (body < range * 0.1) {
          return { name: 'Doji', signal: 'NEUTRAL' };
        }
        
        if (candle.close > candle.open && lowerWick > body * 2 && upperWick < body * 0.3) {
          return { name: 'Hammer', signal: 'BULLISH' };
        }
        
        if (candle.close < candle.open && upperWick > body * 2 && lowerWick < body * 0.3) {
          return { name: 'Shooting Star', signal: 'BEARISH' };
        }
        
        if (candle.close > candle.open && body > range * 0.7) {
          return { name: 'Strong Bullish', signal: 'BULLISH' };
        }
        
        if (candle.close < candle.open && body > range * 0.7) {
          return { name: 'Strong Bearish', signal: 'BEARISH' };
        }
        
        return { name: 'No Pattern', signal: 'NEUTRAL' };
      };

      const findSwingPoints = (candles) => {
        const swingPoints = [];
        const lookback = 5; // Number of candles to look back/forward for swing detection
        
        for (let i = lookback; i < candles.length - lookback; i++) {
          const current = candles[i];
          const leftCandles = candles.slice(i - lookback, i);
          const rightCandles = candles.slice(i + 1, i + lookback + 1);
          
          // Check for swing high (wick high is highest among surrounding candles)
          const isSwingHigh = leftCandles.every(c => current.high >= c.high) && 
                              rightCandles.every(c => current.high >= c.high);
          
          // Check for swing low (wick low is lowest among surrounding candles)
          const isSwingLow = leftCandles.every(c => current.low <= c.low) && 
                             rightCandles.every(c => current.low <= c.low);
          
          if (isSwingHigh) {
            swingPoints.push({
              index: i,
              time: candles[i].time,
              price: current.high,
              type: 'high'
            });
          }
          
          if (isSwingLow) {
            swingPoints.push({
              index: i,
              time: candles[i].time,
              price: current.low,
              type: 'low'
            });
          }
        }
        
        return swingPoints;
      };

      const identifyStructureBreaks = (swingPoints, candles) => {
        const structures = [];
        const lookbackDays = getLookbackDays(structureLookback);
        const lookbackMs = lookbackDays * 24 * 60 * 60 * 1000;
        const cutoffTime = Date.now() - lookbackMs;
        
        // Filter swing points within lookback period
        const recentSwingPoints = swingPoints.filter(p => p.time >= cutoffTime);
        
        // Separate highs and lows
        const highs = recentSwingPoints.filter(p => p.type === 'high');
        const lows = recentSwingPoints.filter(p => p.type === 'low');
        
        // Identify Higher Highs and Lower Highs
        for (let i = 1; i < highs.length; i++) {
          const currentHigh = highs[i];
          const prevHigh = highs[i - 1];
          
          if (currentHigh.price > prevHigh.price) {
            // This is a Higher High (HH)
            // Check if HH price is within 5% of any more recent LH or LL
            let shouldFlag = true;
            
            // Find all LH that came after this HH
            const laterLowerHighs = highs.slice(i + 1).filter((h, idx) => {
              const nextHigh = highs[i + 1 + idx];
              return nextHigh && nextHigh.price < highs[i + idx].price;
            });
            
            // Find all LL that came after this HH
            const laterLowerLows = lows.filter(l => l.time > currentHigh.time).filter((l, idx, arr) => {
              if (idx === 0) return false;
              return l.price < arr[idx - 1].price;
            });
            
            // Check if within 5% of any later LH or LL
            for (const lh of laterLowerHighs) {
              if (Math.abs(currentHigh.price - lh.price) / currentHigh.price <= 0.05) {
                shouldFlag = false;
                break;
              }
            }
            
            if (shouldFlag) {
              for (const ll of laterLowerLows) {
                if (Math.abs(currentHigh.price - ll.price) / currentHigh.price <= 0.05) {
                  shouldFlag = false;
                  break;
                }
              }
            }
            
            if (shouldFlag) {
              structures.push({
                ...currentHigh,
                structure: 'HH',
                color: '#10b981'
              });
            }
          } else if (currentHigh.price < prevHigh.price) {
            // This is a Lower High (LH)
            // Check if LH price is within 5% of any more recent HH or HL
            let shouldFlag = true;
            
            // Find all HH that came after this LH
            const laterHigherHighs = highs.slice(i + 1).filter((h, idx) => {
              const nextHigh = highs[i + 1 + idx];
              return nextHigh && nextHigh.price > highs[i + idx].price;
            });
            
            // Find all HL that came after this LH
            const laterHigherLows = lows.filter(l => l.time > currentHigh.time).filter((l, idx, arr) => {
              if (idx === 0) return false;
              return l.price > arr[idx - 1].price;
            });
            
            // Check if within 5% of any later HH or HL
            for (const hh of laterHigherHighs) {
              if (Math.abs(currentHigh.price - hh.price) / currentHigh.price <= 0.05) {
                shouldFlag = false;
                break;
              }
            }
            
            if (shouldFlag) {
              for (const hl of laterHigherLows) {
                if (Math.abs(currentHigh.price - hl.price) / currentHigh.price <= 0.05) {
                  shouldFlag = false;
                  break;
                }
              }
            }
            
            if (shouldFlag) {
              structures.push({
                ...currentHigh,
                structure: 'LH',
                color: '#ef4444'
              });
            }
          }
        }
        
        // Identify Higher Lows and Lower Lows
        for (let i = 1; i < lows.length; i++) {
          const currentLow = lows[i];
          const prevLow = lows[i - 1];
          
          if (currentLow.price > prevLow.price) {
            // This is a Higher Low (HL)
            // Check if HL price is within 5% of any more recent LH or LL
            let shouldFlag = true;
            
            // Find all LH that came after this HL
            const laterLowerHighs = highs.filter(h => h.time > currentLow.time).filter((h, idx, arr) => {
              if (idx === 0) return false;
              return h.price < arr[idx - 1].price;
            });
            
            // Find all LL that came after this HL
            const laterLowerLows = lows.slice(i + 1).filter((l, idx) => {
              const nextLow = lows[i + 1 + idx];
              return nextLow && nextLow.price < lows[i + idx].price;
            });
            
            // Check if within 5% of any later LH or LL
            for (const lh of laterLowerHighs) {
              if (Math.abs(currentLow.price - lh.price) / currentLow.price <= 0.05) {
                shouldFlag = false;
                break;
              }
            }
            
            if (shouldFlag) {
              for (const ll of laterLowerLows) {
                if (Math.abs(currentLow.price - ll.price) / currentLow.price <= 0.05) {
                  shouldFlag = false;
                  break;
                }
              }
            }
            
            if (shouldFlag) {
              structures.push({
                ...currentLow,
                structure: 'HL',
                color: '#10b981'
              });
            }
          } else if (currentLow.price < prevLow.price) {
            // This is a Lower Low (LL)
            // Check if LL price is within 5% of any more recent HH or HL
            let shouldFlag = true;
            
            // Find all HH that came after this LL
            const laterHigherHighs = highs.filter(h => h.time > currentLow.time).filter((h, idx, arr) => {
              if (idx === 0) return false;
              return h.price > arr[idx - 1].price;
            });
            
            // Find all HL that came after this LL
            const laterHigherLows = lows.slice(i + 1).filter((l, idx) => {
              const nextLow = lows[i + 1 + idx];
              return nextLow && nextLow.price > lows[i + idx].price;
            });
            
            // Check if within 5% of any later HH or HL
            for (const hh of laterHigherHighs) {
              if (Math.abs(currentLow.price - hh.price) / currentLow.price <= 0.05) {
                shouldFlag = false;
                break;
              }
            }
            
            if (shouldFlag) {
              for (const hl of laterHigherLows) {
                if (Math.abs(currentLow.price - hl.price) / currentLow.price <= 0.05) {
                  shouldFlag = false;
                  break;
                }
              }
            }
            
            if (shouldFlag) {
              structures.push({
                ...currentLow,
                structure: 'LL',
                color: '#ef4444'
              });
            }
          }
        }
        
        return structures;
      };

      const analyzeData = (candles) => {
        const macd = calculateMACD(candles);
        const lastCandle = candles[candles.length - 1];
        const pattern = detectCandlePattern(lastCandle);
        const swingPoints = findSwingPoints(candles);
        const structures = identifyStructureBreaks(swingPoints, candles);
        
        // Still find support/resistance for the summary cards
        const levels = swingPoints.filter(p => p.type === 'high' || p.type === 'low');
        
        const avgVolume = candles.reduce((sum, c) => sum + c.volume, 0) / candles.length;
        const volumeSignal = lastCandle.volume > avgVolume * 1.2 ? 'HIGH' : 
                            lastCandle.volume < avgVolume * 0.8 ? 'LOW' : 'NORMAL';
        
        const lastMacd = macd.histogram[macd.histogram.length - 1];
        const prevMacd = macd.histogram[macd.histogram.length - 2];
        
        let macdSignal = 'NEUTRAL';
        if (lastMacd > 0 && prevMacd <= 0) macdSignal = 'BULLISH CROSS';
        else if (lastMacd < 0 && prevMacd >= 0) macdSignal = 'BEARISH CROSS';
        else if (lastMacd > 0) macdSignal = 'BULLISH';
        else if (lastMacd < 0) macdSignal = 'BEARISH';
        
        const currentPrice = lastCandle.close;
        const nearSupport = levels.filter(l => l.type === 'low' && l.price < currentPrice)
          .sort((a, b) => b.price - a.price)[0];
        const nearResistance = levels.filter(l => l.type === 'high' && l.price > currentPrice)
          .sort((a, b) => a.price - b.price)[0];
        
        let score = 0;
        const signals = [];
        
        if (macdSignal.includes('BULLISH')) {
          score += 2;
          signals.push({ name: 'MACD ' + macdSignal, type: 'BULLISH' });
        } else if (macdSignal.includes('BEARISH')) {
          score -= 2;
          signals.push({ name: 'MACD ' + macdSignal, type: 'BEARISH' });
        }
        
        if (pattern.signal === 'BULLISH') {
          score += 1;
          signals.push({ name: 'Pattern: ' + pattern.name, type: 'BULLISH' });
        } else if (pattern.signal === 'BEARISH') {
          score -= 1;
          signals.push({ name: 'Pattern: ' + pattern.name, type: 'BEARISH' });
        }
        
        if (volumeSignal === 'HIGH') {
          signals.push({ name: 'High Volume', type: 'NEUTRAL' });
        }
        
        if (nearSupport && (currentPrice - nearSupport.price) / currentPrice < 0.02) {
          score += 1;
          signals.push({ name: 'Near Support', type: 'BULLISH' });
        }
        
        if (nearResistance && (nearResistance.price - currentPrice) / currentPrice < 0.02) {
          score -= 1;
          signals.push({ name: 'Near Resistance', type: 'BEARISH' });
        }
        
        let overallSignal = 'NEUTRAL';
        if (score >= 3) overallSignal = 'STRONG BUY';
        else if (score >= 1) overallSignal = 'BUY';
        else if (score <= -3) overallSignal = 'STRONG SELL';
        else if (score <= -1) overallSignal = 'SELL';
        
        return {
          macdSignal,
          pattern,
          volumeSignal,
          nearSupport,
          nearResistance,
          currentPrice,
          overallSignal,
          score,
          signals,
          avgVolume: avgVolume.toFixed(0),
          currentVolume: lastCandle.volume.toFixed(0),
          structures // Add structure breaks to analysis
        };
      };

      useEffect(() => {
        const candles = generateData();
        setData(candles);
        setAnalysis(analyzeData(candles));
      }, []);

      useEffect(() => {
        if (data.length > 0 && chartContainerRef.current) {
          createTradingViewChart();
        }
        
        return () => {
          if (chartRef.current) {
            chartRef.current.remove();
            chartRef.current = null;
          }
        };
      }, [data]);

      const createTradingViewChart = () => {
        if (!window.LightweightCharts) {
          console.error('TradingView Lightweight Charts library not loaded');
          return;
        }

        // Remove existing chart
        if (chartRef.current) {
          chartRef.current.remove();
        }

        const container = chartContainerRef.current;
        
        // Determine time visibility based on timeframe
        const showTime = timeframe === '5min' || timeframe === '15min' || timeframe === 'hour';
        
        // Create chart
        const chart = window.LightweightCharts.createChart(container, {
          width: container.clientWidth,
          height: 500,
          layout: {
            background: { color: '#ffffff' },
            textColor: '#333'
          },
          grid: {
            vertLines: { color: '#f0f0f0' },
            horzLines: { color: '#f0f0f0' }
          },
          crosshair: {
            mode: window.LightweightCharts.CrosshairMode.Normal
          },
          rightPriceScale: {
            borderColor: '#d1d4dc'
          },
          timeScale: {
            borderColor: '#d1d4dc',
            timeVisible: showTime,
            secondsVisible: false,
            lockVisibleTimeRangeOnResize: true
          },
          handleScroll: {
            mouseWheel: true,
            pressedMouseMove: true,
            horzTouchDrag: true,
            vertTouchDrag: true
          },
          handleScale: {
            axisPressedMouseMove: true,
            mouseWheel: true,
            pinch: true
          }
        });

        // Add candlestick series
        const candlestickSeries = chart.addCandlestickSeries({
          upColor: '#10b981',
          downColor: '#ef4444',
          borderUpColor: '#10b981',
          borderDownColor: '#ef4444',
          wickUpColor: '#10b981',
          wickDownColor: '#ef4444'
        });

        // Format data for TradingView - convert ms timestamp to seconds
        const chartData = data.map((candle) => ({
          time: Math.floor(candle.time / 1000), // Convert ms to seconds for TradingView
          open: candle.open,
          high: candle.high,
          low: candle.low,
          close: candle.close
        }));

        candlestickSeries.setData(chartData);

        // Add structure break lines (HH, HL, LH, LL)
        if (analysis && analysis.structures) {
          analysis.structures.forEach(structure => {
            const structureTime = Math.floor(structure.time / 1000);
            const lastTime = Math.floor(data[data.length - 1].time / 1000);
            
            // Create horizontal line from structure point to end of chart
            const lineSeries = chart.addLineSeries({
              color: structure.color,
              lineWidth: 2,
              lineStyle: window.LightweightCharts.LineStyle.Dashed,
              crosshairMarkerVisible: false,
              lastValueVisible: true,
              priceLineVisible: false
            });
            
            // Draw line from the structure point to the right edge
            lineSeries.setData([
              { time: structureTime, value: structure.price },
              { time: lastTime, value: structure.price }
            ]);
            
            // Add marker for the structure point
            candlestickSeries.setMarkers([
              ...candlestickSeries.markers() || [],
              {
                time: structureTime,
                position: structure.type === 'high' ? 'aboveBar' : 'belowBar',
                color: structure.color,
                shape: structure.type === 'high' ? 'arrowDown' : 'arrowUp',
                text: structure.structure
              }
            ]);
          });
        }

        chart.timeScale().fitContent();

        // Handle resize
        const handleResize = () => {
          chart.applyOptions({ width: container.clientWidth });
        };
        window.addEventListener('resize', handleResize);

        chartRef.current = {
          chart,
          remove: () => {
            window.removeEventListener('resize', handleResize);
            chart.remove();
          }
        };
      };

      const resetZoom = () => {
        if (chartRef.current && chartRef.current.chart) {
          chartRef.current.chart.timeScale().fitContent();
        }
      };

      const handleSearch = async () => {
        if (dataSource === 'real') {
          const candles = await fetchRealData(ticker);
          if (candles) {
            setData(candles);
            setAnalysis(analyzeData(candles));
          }
        } else {
          const candles = generateData();
          setData(candles);
          setAnalysis(analyzeData(candles));
        }
      };

      const refresh = () => {
        handleSearch();
      };

      if (!analysis) return <div className="p-8">Loading...</div>;

      const getColor = (signal) => {
        if (signal.includes('BUY')) return 'text-green-600';
        if (signal.includes('SELL')) return 'text-red-600';
        return 'text-gray-600';
      };

      const getBg = (signal) => {
        if (signal.includes('BUY')) return 'bg-green-100 border-green-300';
        if (signal.includes('SELL')) return 'bg-red-100 border-red-300';
        return 'bg-gray-100 border-gray-300';
      };

      return (
        <div className="min-h-screen bg-gray-50 p-6">
          <div className="max-w-6xl mx-auto">
            <div className="flex justify-between items-center mb-8">
              <h1 className="text-3xl font-bold">Trading Analyzer</h1>
              <button onClick={refresh} disabled={loading} className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50">
                {loading ? 'Loading...' : 'Refresh'}
              </button>
            </div>

            <div className="bg-white p-6 rounded-lg shadow mb-8">
              <div className="grid grid-cols-1 md:grid-cols-5 gap-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">Data Source</label>
                  <select 
                    value={dataSource} 
                    onChange={(e) => setDataSource(e.target.value)}
                    className="w-full px-4 py-2 border border-gray-300 rounded-lg"
                  >
                    <option value="demo">Demo Data</option>
                    <option value="real">Real Market Data</option>
                  </select>
                </div>
                
                {dataSource === 'real' && (
                  <>
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">Ticker Symbol</label>
                      <input
                        type="text"
                        value={ticker}
                        onChange={(e) => setTicker(e.target.value.toUpperCase())}
                        placeholder="AAPL, TSLA, MSFT..."
                        className="w-full px-4 py-2 border border-gray-300 rounded-lg"
                      />
                    </div>
                    
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">Timeframe</label>
                      <select 
                        value={timeframe} 
                        onChange={(e) => setTimeframe(e.target.value)}
                        className="w-full px-4 py-2 border border-gray-300 rounded-lg"
                      >
                        <option value="5min">5 Minutes</option>
                        <option value="15min">15 Minutes</option>
                        <option value="hour">1 Hour</option>
                        <option value="day">Daily</option>
                        <option value="week">Weekly</option>
                      </select>
                    </div>
                    
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">Structure Lookback</label>
                      <select 
                        value={structureLookback} 
                        onChange={(e) => setStructureLookback(e.target.value)}
                        className="w-full px-4 py-2 border border-gray-300 rounded-lg"
                      >
                        <option value="5days">5 Days</option>
                        <option value="10days">10 Days</option>
                        <option value="15days">15 Days</option>
                        <option value="1month">1 Month</option>
                        <option value="3months">3 Months</option>
                        <option value="6months">6 Months</option>
                        <option value="9months">9 Months</option>
                        <option value="1year">1 Year</option>
                        <option value="2years">2 Years</option>
                      </select>
                    </div>
                  </>
                )}
                
                <div className="flex items-end">
                  <button 
                    onClick={handleSearch} 
                    disabled={loading}
                    className="w-full px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50"
                  >
                    {loading ? 'Searching...' : 'Search'}
                  </button>
                </div>
              </div>
              
              {error && (
                <div className="mt-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded">
                  <p className="font-bold">Error:</p>
                  <p>{error}</p>
                  <p className="text-sm mt-2">Try: AAPL, TSLA, MSFT, GOOGL, AMZN, NVDA</p>
                </div>
              )}
            </div>

            <div className={`p-8 rounded-lg shadow mb-8 border-2 ${getBg(analysis.overallSignal)}`}>
              <h2 className="text-xl font-semibold mb-2">
                Overall Signal {dataSource === 'real' ? `- ${ticker} (${timeframe.toUpperCase()})` : '(Demo)'}
              </h2>
              <div className={`text-5xl font-bold ${getColor(analysis.overallSignal)}`}>
                {analysis.overallSignal}
              </div>
              <div className="text-gray-600 mt-2">Score: {analysis.score}</div>
              <div className="text-gray-800 mt-1 text-lg">Price: ${analysis.currentPrice.toFixed(2)}</div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
              <div className="bg-white p-6 rounded-lg shadow">
                <h3 className="text-xl font-semibold mb-4">MACD Analysis</h3>
                <div className="text-2xl font-bold text-blue-600 mb-2">{analysis.macdSignal}</div>
                <p className="text-gray-600">Moving Average Convergence Divergence indicator showing momentum</p>
              </div>

              <div className="bg-white p-6 rounded-lg shadow">
                <h3 className="text-xl font-semibold mb-4">Volume Analysis</h3>
                <div className="text-2xl font-bold text-purple-600 mb-2">{analysis.volumeSignal}</div>
                <div className="text-sm text-gray-600">Current: {analysis.currentVolume}</div>
                <div className="text-sm text-gray-600">Average: {analysis.avgVolume}</div>
              </div>

              <div className="bg-white p-6 rounded-lg shadow">
                <h3 className="text-xl font-semibold mb-4">Candlestick Pattern</h3>
                <div className="text-2xl font-bold text-orange-600 mb-2">{analysis.pattern.name}</div>
                <div className={`text-lg ${getColor(analysis.pattern.signal)}`}>{analysis.pattern.signal}</div>
              </div>

              <div className="bg-white p-6 rounded-lg shadow">
                <h3 className="text-xl font-semibold mb-4">Support & Resistance</h3>
                {analysis.nearResistance && (
                  <div className="mb-3">
                    <div className="text-sm text-gray-600">Resistance</div>
                    <div className="text-xl font-bold text-red-600">${analysis.nearResistance.price.toFixed(2)}</div>
                  </div>
                )}
                {analysis.nearSupport && (
                  <div>
                    <div className="text-sm text-gray-600">Support</div>
                    <div className="text-xl font-bold text-green-600">${analysis.nearSupport.price.toFixed(2)}</div>
                  </div>
                )}
              </div>
            </div>

            <div className="bg-white p-6 rounded-lg shadow mb-8">
              <h3 className="text-xl font-semibold mb-4">Active Signals</h3>
              <div className="space-y-2">
                {analysis.signals.map((sig, i) => (
                  <div key={i} className={`p-4 rounded ${
                    sig.type === 'BULLISH' ? 'bg-green-50 border border-green-200' :
                    sig.type === 'BEARISH' ? 'bg-red-50 border border-red-200' :
                    'bg-gray-50 border border-gray-200'
                  }`}>
                    <div className="flex justify-between items-center">
                      <span className="font-semibold">{sig.name}</span>
                      <span className={`px-3 py-1 rounded text-sm font-bold ${
                        sig.type === 'BULLISH' ? 'bg-green-600 text-white' :
                        sig.type === 'BEARISH' ? 'bg-red-600 text-white' :
                        'bg-gray-600 text-white'
                      }`}>
                        {sig.type}
                      </span>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            <div className="bg-white p-6 rounded-lg shadow">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-xl font-semibold">Interactive Candlestick Chart</h3>
                <button 
                  onClick={resetZoom}
                  className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 text-sm"
                >
                  Reset Zoom
                </button>
              </div>
              <div className="text-sm text-gray-600 mb-4">
                ðŸ’¡ <strong>Scroll</strong> to zoom in/out â€¢ <strong>Click & drag</strong> to pan â€¢ <span className="text-green-600 font-semibold">Green</span> = bullish â€¢ <span className="text-red-600 font-semibold">Red</span> = bearish
                <br />
                ðŸ“Š <strong>HH</strong> = Higher High â€¢ <strong>HL</strong> = Higher Low â€¢ <strong>LH</strong> = Lower High â€¢ <strong>LL</strong> = Lower Low
              </div>
              <div ref={chartContainerRef} style={{width: '100%', height: '500px'}}></div>
              <div className="text-xs text-gray-500 mt-2">
                Powered by <a href="https://www.tradingview.com/" target="_blank" rel="noopener" className="text-blue-600 hover:underline">TradingView</a>
              </div>
            </div>
          </div>
        </div>
      );
    };

    ReactDOM.render(<TradingApp />, document.getElementById('root'));
  </script>
</body>
</html>
